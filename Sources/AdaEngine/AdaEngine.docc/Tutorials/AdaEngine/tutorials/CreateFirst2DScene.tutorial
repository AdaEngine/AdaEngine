@Tutorial(time: 20) {
    @Intro(title: "Create your first 2D scene") {
        
        In this tutorial, you will learn how to create your first 2D scene using AdaEngine.
    }
    
    @XcodeRequirement(title: "Xcode 26.2 or later", destination: "https://developer.apple.com/download/")
    
    @Section(title: "Intro") {
        @ContentAndMedia {
            For the first 2D scene, we will try to repeat this example. We'll look at adding a scene and a camera. 
            In addition, we'll learn how to add sprites and movement systems.
            @Video(source: "CF2G-3-5.mov", alt: "")
        }
    }
    
    @Section(title: "Create an app") {
        @ContentAndMedia {
            First, we need to create base files to launch our application.
        }
        
        @Steps {
            @Step {
                In the previous tutorial, we've created an app and an empty window scene. 
                
                @Code(name: "FirstGameApp.swift", file: CF2G-1-1-app.swift)
            }
            
            @Step {
                Let's create the game logic. To do this, let's create a file named `FirstScene.swift` and import AdaEngine. 
                After that, create a struct named `FirstScene` that conforms to `Plugin` and add a method named `setup(in app: AppWorlds)` where we will set up entities in our game world.
                
                @Code(name: "FirstScene.swift", file: CF2G-1-2-scene.swift)
            }
            
            @Step {
                Now add the `FirstScene` plugin to the app using the `addPlugins` method.
                
                @Code(name: "FirstGameApp.swift", file: CF2G-1-4-app.swift)
            }
        }
    }
        
    @Section(title: "Create a main camera.") {
        @ContentAndMedia {
            AdaEngine uses the Entity Component System paradigm where all game objects are called ``Entity``.
            Entities are objects that store user or engine data like position, scale, mesh instance, audio, etc. This data is called components, and they should conform to the ``Component`` protocol.
            By default, ``Entity`` is an empty object without any components.
            
            @Comment {
                We should link to ECS article here
            }
        }
        
        ``Camera`` is a component that determines where all entities will be rendered. AdaEngine supports rendering to a texture or to the ``Window``. We recommend using engine component bundles like ``Camera2D`` or ``Camera3D``, because the engine provides additional components for rendering and audio capabilities.
        
        @Steps {
            @Step {
                Let's create our 2D camera. Spawn an entity with the ``Camera2D`` bundle. 
                
                @Code(name: "FirstScene.swift", file: CF2G-2-1-camera.swift)
            }
            
            @Step {
                Now let's fill the camera background with a sky blue color.
                
                @Code(name: "FirstScene.swift", file: CF2G-2-2-camera.swift) {
                    @Image(source: "CF2G-2-1.png", alt: "Empty window with blue color")
                }
            }
        }
    }
        
    @Section(title: "First sprite") {
        @ContentAndMedia {
            Now we can create our first custom sprite.
        }
        
        @Steps {
            @Step {
                First, we should create an assets folder where we will store our game assets, like sprite sheets, sounds, shaders, etc. Let's create a folder named `Assets` and add any sprite sheets you want. We will use this sprite sheet:
                
                @Image(source: "CF2G-3-1.png", alt: "Our sprite sheet")
            }
            
            @Step {
                In the end, we should have this file structure in our project. AdaEngine doesn't use xcassets.
                
                You can download this texture by right-clicking on the image and saving it to the downloads folder. 
                
                @Image(source: "CF2G-3-2.png", alt: "Our sprite sheet")
            }
            
            @Step {
                Spawn a player entity in the game world. The player entity will store our sprite component and other player data in the future.
                
                @Code(name: "FirstScene.swift", file: CF2G-3-1-sprite.swift)
            }
            
            @Step {
                Let's create an image from a file using a special resource manager object. ``AssetsManager`` manages and caches game and engine resources. In our case, we should load an image from a file named `characters_packed.png` and use `Bundle.main` as a search path.
                
                @Code(name: "FirstScene.swift", file: CF2G-3-2-sprite.swift)
            }
            
            @Step {
                To split the sprite sheet image into sprites, we can use the ``TextureAtlas`` object. This object takes an image, sprite size, and margin between sprites if needed. In our case, we have a margin between sprites of 4px horizontally and 1px vertically, and a sprite size of 20px width and 23px height.
                
                @Code(name: "FirstScene.swift", file: CF2G-3-3-sprite.swift)
            }
            
            @Step {
                Now we can add our sprite to the player entity using the ``Sprite`` component. This component is efficient for rendering because it uses a special batching system and requires fewer drawing calls. 
                
                Add a new sprite component to the entity in the `spawn` method. As you can see, we use subscripts in our `TextureAtlas` instance where 7 is the column number in our sprite sheet and 1 is the row number.
                
                @Code(name: "FirstScene.swift", file: CF2G-3-4-sprite.swift) {
                    @Image(source: "CF2G-3-3.png", alt: "Our sprite sheet")
                }
            }
            
            @Step {
                And finally, let's add a special ``Transform`` component that describes the position of our entity on the screen. 
                
                @Code(name: "FirstScene.swift", file: CF2G-3-5-sprite.swift) {
                    @Image(source: "CF2G-3-4.png", alt: "Our sprite sheet")
                }
            }
        }
    }
        
    @Section(title: "Make it move") {
        @ContentAndMedia {
            We did a lot of work, but our scene looks very simple. We should add more life to our player entity. All game logic is described in special objects named ``System``. A system is a unit that executes each game loop and manipulates entities and their data. We will use one to add life to our player.
        }
            
        @Steps {
            @Step {
                First, we should create a special tag component named `PlayerComponent`. We will use this component in the near future; it indicates that this entity is a player.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-1-player.swift)
            }
            
            @Step {
                Create a new function named `PlayerMovement` and annotate this function with the ``System`` macro. This system will listen to user inputs and move our player component on the screen.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-2-player.swift)
            }
            
            @Step {
                Add the new system to our game scene. The ``System`` macro will create a new system with the same name as the function with the suffix `System`. Our system will be initialized once on app launch.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-3-player.swift)
            }
            
            @Step {
                In `PlayerMovementSystem`, add a new function parameter named `playerTransform` with the `FilterQuery<Ref<Transform>, With<PlayerComponent>>` type. 
                This object will query the world and return components that conform to your predicate. In our case, we require one mutable component ``Transform`` and a filter that indicates we need entities with the ``PlayerComponent``.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-4-player.swift)
            }
            
            @Step {
                Add a new function parameter named `speed` with the `Local<Float>` type. This is a special type that stores a value available only within the system.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-5-player.swift)
            }

            Now we can update our player position. AdaEngine can handle keyboard inputs for us. We should listen to keyboard inputs, and if a key is pressed, we should change the player transform.
            
            @Step {
                Let's add a new function parameter named `deltaTime` with the `Res<DeltaTime>` type and `input` with `Res<Input>`. These are queries to resources in the world.

                Using the special ``Input`` object, we can check if a key is pressed.
                Add an `if` condition where we will listen to the `w` key. If the key is pressed, add the speed multiplied by delta time. We do this for a smooth transition between frames.   
                
                @Code(name: "FirstScene.swift", file: CF2G-4-6-player.swift)
            }
            
            @Step {
                Finally, add the same logic for other keys â€” `a`, `s`, and `d`.
                
                Run the app and try to move your player.
                
                @Code(name: "FirstScene.swift", file: CF2G-4-7-player.swift) {
                    @Video(source: "CF2G-3-5.mov", alt: "")
                }
            }
        }
    }
}
