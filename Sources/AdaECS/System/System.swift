//
//  System.swift
//  AdaEngine
//
//  Created by v.prusakov on 5/6/22.
//

import AdaUtils

/// Contains information about current world update.
public struct WorldUpdateContext: @unchecked Sendable, ~Copyable {
    /// The updating world.
    public let world: World

    /// The scheduler that will be used to schedule tasks.
    public let scheduler: SchedulerName

    /// Custom task group that will be executed when system did finish update block.
//    public var taskGroup: DiscardingTaskGroup

    /// Initialize a new world update context.
    /// - Parameter world: The world that will be updated.
    /// - Parameter deltaTime: The delta time that will be used to update the world.
    /// - Parameter scheduler: The scheduler that will be used to schedule tasks.
    /// - Parameter taskGroup: The task group that will be executed when the system did finish update block.
    init(
        world: consuming World,
        scheduler: SchedulerName
    ) {
        self.world = world
        self.scheduler = scheduler
    }
}

/// An object that affects multiple entities in every frame.
///
/// System is a fundomental part of ECS paradigm.
/// Use systems to implement any behavior or logic that updates entities every frame,
/// such as different types of objects or characters. For example, a physics simulation system calculates and applies the affect of gravity, forces, and collisions for all entities.
///
/// A complex game or experience may consist of many systems which need to be executed in a specific order.
/// The dependencies property defines when the update method for each system is called each frame. Update order is defined between system types and not between individual system instances.
///
/// Like example, let's create a movement system:
///
/// ```swift
/// @System
/// struct MovementSystem {
///
///     // Configure the query to world.
///     // We want to recieve entities with `PlayerComponent` and `Transform`
///     @EntityQuery(where: .has(Transform.self) && .has(PlayerComponent.self))
///     private var query
///
///     init(world: World) {}
///
///     func update(context: inout UpdateContext) {
///         self.query.forEach { entity in
///             // Get transform component from entity
///             let transform = entity.components[Transform.self]!
///
///             if Input.isKeyPressed(.space) {
///                 // Add 5 points for vertical direction
///                 // if space button pressed
///                 transform.position.y += 5
///             }
///         }
///     }
/// }
///
/// ```
public protocol System: Sendable {

    typealias UpdateContext = WorldUpdateContext

    /// Creates a new system.
    @preconcurrency init(world: World)

    /// Updates entities every frame.
    func update(context: inout UpdateContext) async

    /// An array of queries for this system.
    /// That needs to be updated queries results for this system.
    /// You can ignore this property if you don't use ``EntityQuery`` property wrapper or similar query property wrappers.
    /// - Note: This property is automatically generated by ``System(dependencies:)`` or ``PlainSystem(dependencies:)`` macro. Macro grab all properties with `Query` suffix and confirmed ``SystemQuery`` protocol, example: `@CustomQuery`.
    var queries: SystemQueries { get }

    // MARK: Dependencies

    /// An array of dependencies for this system.
    static var dependencies: [SystemDependency] { get }
}

public extension System {
    static var dependencies: [SystemDependency] {
        return []
    }

    var queries: SystemQueries {
        return SystemQueries(queries: [])
    }
}

/// A collection of queries for a system.
public struct SystemQueries: Sendable, Equatable {
    
    public let queries: [any SystemQuery]

    /// Initialize a new system queries.
    /// - Parameter queries: The queries to update.
    public init(queries: consuming [any SystemQuery]) {
        self.queries = queries
    }

    /// Update the queries from the world.
    /// - Parameter world: The world to update the queries from.
    public func update(from world: consuming World) {
        let world = world
        for query in queries {
            query.update(from: world)
        }
    }

    public static func == (lhs: SystemQueries, rhs: SystemQueries) -> Bool {
        for lhsItem in lhs.queries {
            let lhsItemType = type(of: lhsItem)
            if rhs.queries.contains(where: {
                type(of: $0) == lhsItemType
            }) {
                return false
            }
        }

        return true
    }
}
