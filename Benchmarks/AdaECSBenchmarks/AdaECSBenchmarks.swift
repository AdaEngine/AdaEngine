// Benchmark boilerplate generated by Benchmark

import AdaECS
import Benchmark

@Component
private struct Position {
    var x: Float
    var y: Float
}

@Component
private struct Velocity {
    var x: Float
    var y: Float
}

@Component
private struct Health {
    var value: Int32
}

@Component
private struct Mana {
    var value: Int32
}

@Component
private struct Rotation {
    var angle: Float
}

@Component
private struct Scale {
    var value: Float
}

private enum BenchConstants {
    static let simpleInsertEntities = 1_000_000
    static let simpleIterEntities = 1_000_000
    static let fragmentedIterEntities = 1_000_000
    static let addRemoveEntities = 1_000_000
    static let fragmentArchetypeCount = 5
}

private func makeSimpleIterWorld(entityCount: Int) -> (World, Query<Position, Velocity>) {
    let world = World()
    for i in 0..<entityCount {
        world.spawn {
            Position(x: Float(i), y: Float(i))
            Velocity(x: 1, y: -1)
            Health(value: Int32(i))
        }
    }

    let query = Query<Position, Velocity>()
    query.update(from: world)

    return (world, query)
}

private func makeFragmentedIterWorld(
    entityCount: Int,
    archetypeCount: Int
) -> (World, Query<Position, Velocity>) {
    let world = World()

    for i in 0..<entityCount {
        switch i % archetypeCount {
        case 0:
            world.spawn {
                Position(x: Float(i), y: Float(i))
                Velocity(x: 1, y: -1)
            }
        case 1:
            world.spawn {
                Position(x: Float(i), y: Float(i))
                Velocity(x: 1, y: -1)
                Health(value: Int32(i))
            }
        case 2:
            world.spawn {
                Position(x: Float(i), y: Float(i))
                Health(value: Int32(i))
                Mana(value: Int32(i & 0xff))
            }
        case 3:
            world.spawn {
                Position(x: Float(i), y: Float(i))
                Velocity(x: 1, y: -1)
                Rotation(angle: Float(i))
            }
        default:
            world.spawn {
                Position(x: Float(i), y: Float(i))
                Mana(value: Int32(i & 0xff))
                Scale(value: 1)
            }
        }
    }

    let query = Query<Position, Velocity>()
    query.update(from: world)

    return (world, query)
}

private func makeAddRemoveWorld(entityCount: Int) -> (World, [Entity.ID]) {
    let world = World()
    var ids: [Entity.ID] = []
    ids.reserveCapacity(entityCount)

    for i in 0..<entityCount {
        let entity = world.spawn {
            Position(x: Float(i), y: Float(i))
        }
        ids.append(entity.id)
    }

    return (world, ids)
}

let benchmarks: @Sendable () -> Void = {
    Benchmark("AdaECS.SimpleInsert") { benchmark in
        for _ in benchmark.scaledIterations {
            let world = World()
            for i in 0..<BenchConstants.simpleInsertEntities {
                world.spawn {
                    Position(x: Float(i), y: Float(i))
                    Velocity(x: 1, y: -1)
                    Health(value: Int32(i))
                    Mana(value: Int32(i & 0xff))
                }
            }
            blackHole(world)
        }
    }

    Benchmark(
        "AdaECS.SimpleIter",
        closure: { benchmark, state in
            let (world, query) = state
            for _ in benchmark.scaledIterations {
                var sum: Float = 0
                query.forEach { position, velocity in
                    sum += position.x + velocity.y
                }
                blackHole(sum)
            }
            blackHole(world)
        },
        setup: {
            makeSimpleIterWorld(entityCount: BenchConstants.simpleIterEntities)
        }
    )

    Benchmark(
        "AdaECS.FragmentedIter",
        closure: { benchmark, state in
            let (world, query) = state
            for _ in benchmark.scaledIterations {
                var sum: Float = 0
                query.forEach { position, velocity in
                    sum += position.x + velocity.x
                }
                blackHole(sum)
            }
            blackHole(world)
        },
        setup: {
            makeFragmentedIterWorld(
                entityCount: BenchConstants.fragmentedIterEntities,
                archetypeCount: BenchConstants.fragmentArchetypeCount
            )
        }
    )

    Benchmark(
        "AdaECS.AddRemove",
        closure: { benchmark, state in
            let (world, ids) = state
            for _ in benchmark.scaledIterations {
                for id in ids {
                    world.insert(Velocity(x: 1, y: -1), for: id)
                }
                for id in ids {
                    world.remove(Velocity.self, from: id)
                }
            }
            blackHole(world)
        },
        setup: {
            makeAddRemoveWorld(entityCount: BenchConstants.addRemoveEntities)
        }
    )
}
